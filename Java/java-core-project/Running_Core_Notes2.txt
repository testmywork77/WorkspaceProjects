Java 8 Features
	Lambda Expressions
	Functional Interfaces and Predefined Functional Interfaces
	Method References and Types of Method References
	Optional Class to Avoid NullPointerExceptions
	Default and Static Methods in Interfaces
	Stream API: filter, map, sorting, finding, collecting
 
Java Guides:
	*Why Interfaces Need Default Methods in Java?
		Like regular interface methods, default methods are implicitly public; there's no need to specify the public modifier.

		Unlike regular interface methods, we declare them with the default keyword at the beginning of the method signature, and they provide an implementation.
	
	*Optional Class in Java 8 - Avoid Null Pointer Exception
		Java introduced a new class Optional in JDK 8. It is a public final class and is used to deal with NullPointerException in Java applications.

		The purpose of the class is to provide a type-level solution for representing optional values instead of using null references.
		
		Java 8 has introduced a new "Optional" utility calss in java.util package. This class can help in avoiding null checks and NullPointerException exceptions.

		Optional as single-value container that either contains a value or doesn't(means "empty").

		Advantages of Java 8 Optional
		- Null checks are not required.
		- No more NullPointerException at run-time.
		- We can develop a clean and neat APIs.
		- No more Boilerplate code	
		
		Before Optional Class:
		class model.Employee {
			private Long id;
			private String name;
			private String email;
			private String location;
		}

		model.Employee employee = getEmployee();
		String email = employee.getEmail(); //if employee is null
		String result = email.toLowerCase(); // null pointer exception

		if(employee != null){
		  if(employee.getId() != null){
			// logic goes here
		  } 

		  if(employee.getEmail() != null){
			// logic goes here
		  }

		}

Java 8 Streams API:
Ex:
 int[] numbers = {4, 1, 13, 90, 16, 2, 0 };
 IntStream.of(numbers).min();
 IntStream.of(numbers).max();
 IntStream.of(numbers).average();
 IntStream.of(numbers).count();
 IntStream.of(numbers).sum();